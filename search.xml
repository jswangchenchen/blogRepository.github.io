<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>19-03-24-m3uu8 字段解释</title>
      <link href="/HLS/19-03-24-m3uu8-%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A/"/>
      <url>/HLS/19-03-24-m3uu8-%E5%AD%97%E6%AE%B5%E8%A7%A3%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<p>上次我在之前的一篇博客又说HLS是基于Http协议的，里面的传输内容包括两部分，一个是m3u8文件还有一个就是ts的媒体文件；</p><p> 在m3u8中会有许多的标签，每个标签都有自己相对应的意思；</p><p>在</p><p>今天我从一些博客找到一个关于标签解释的list如下：</p><table><thead><tr><th>#EXTM3U</th><th style="text-align:left">每个M3U文件第一行必须是这个tag。</th></tr></thead><tbody><tr><td>#EXTINF:<duration>,<title></title></duration></td><td style="text-align:left">duration表示持续的时间（秒）必须是整数，如果版本在3以上可以是浮点数。</td></tr><tr><td>#EXTINF</td><td style="text-align:left">指定每个媒体段(ts)的持续时间，这个仅对其后面的URI有效，每两个媒体段URI间被这个tag分隔开。</td></tr><tr><td>#EXT-X-BYTERANGE</td><td style="text-align:left">表示媒体段是一个媒体URI资源中的一段，只对其后的media URI有效，格式如下：#EXT-X-BYTERANGE:<n>[@o]其中n表示这个区间的大小，o表在URI中的offset；”The EXT-X-BYTERANGE tag appeared in version 4 of the protocol“。</n></td></tr><tr><td>#EXT-X-TARGETDURATION</td><td style="text-align:left">指定最大的媒体段时间长（秒）。所以#EXTINF中指定的时间长度必须小于或是等于这个最大值。这个tag在整个PlayList文件中只能出现一 次（在嵌套的情况下，一般有真正ts url的m3u8才会出现该tag）。格式如下：#EXT-X-TARGETDURATION:<s>：s表示最大的秒数。</s></td></tr><tr><td>#EXT-X-MEDIA-SEQUENCE</td><td style="text-align:left">每一个media URI 在 PlayList中只有唯一的序号，相邻之间序号+1。</td></tr><tr><td>#EXT-X-MEDIA-SEQUENCE:<number></number></td><td style="text-align:left">一个media URI并不是必须要包含的，如果没有，默认为0。</td></tr><tr><td>#EXT-X-KEY</td><td style="text-align:left">表示怎么对media segments进行解码。其作用范围是下次该tag出现前的所有media URI，格式如下：#EXT-X-KEY:<attribute-list>：NONE 或者 AES-128。如果是NONE，则URI以及IV属性必须不存在，如果是AES-128(Advanced EncryptionStandard)，则URI必须存在，IV可以不存在。对于AES-128的情况，keytag和URI属性共同表示了一个key文件，通过URI可以获得这个key，如果没有IV（Initialization Vector）,则使用序列号作为IV进行编解码，将序列号的高位赋到16个字节的buffer中，左边补0；如果有IV，则将改值当成16个字节的16进制数。</attribute-list></td></tr><tr><td>#EXT-X-PROGRAM-DATE-TIME</td><td style="text-align:left">将一个绝对时间或是日期和一个媒体段中的第一个sample相关联，只对下一个meida URI有效，格式如下：#EXT-X-PROGRAM-DATE-TIME:<a href="YYYY-MM-DDThh:mm:ssZ" target="_blank" rel="noopener">YYYY-MM-DDThh:mm:ssZ</a>例如:#EXT-X-PROGRAM-DATE-TIME:2010-02-19T14:54:23.031+08:00</td></tr><tr><td>#EXT-X-ALLOW-CACHE：</td><td style="text-align:left">是否允许做cache，这个可以在PlayList文件中任意地方出现，并且最多出现一次，作用效果是所有的媒体段。格式如下：#EXT-X-ALLOW-CACHE:&lt;YES\</td><td>NO&gt;</td></tr><tr><td>#EXT-X-PLAYLIST-TYPE</td><td style="text-align:left">提供关于PlayList的可变性的信息， 这个对整个PlayList文件有效，是可选的，格式如下：#EXT-X-PLAYLIST-TYPE:&lt;EVENT\</td><td>VOD&gt; ：如果是VOD，则服务器不能改变PlayList 文件；如果是EVENT，则服务器不能改变或是删除PlayList文件中的任何部分，但是可以向该文件中增加新的一行内容。</td></tr><tr><td>#EXT-X-ENDLIST</td><td style="text-align:left">表示PlayList的末尾了，它可以在PlayList中任意位置出现，但是只能出现一个，格式如下：#EXT-X-ENDLIST</td></tr><tr><td>#EXT-X-MEDIA</td><td style="text-align:left">被用来在PlayList中表示相同内容的不用语种/译文的版本，比如可以通过使用3个这种tag表示3中不用语音的音频，或者用2个这个tag表示不同角度的video在PlayLists中。这个标签是独立存在的，其格式如下：#EXT-X-MEDIA:<attribute-list>：该属性列表中包含：URI、TYPE、GROUP-ID、LANGUAGE、NAME、DEFAULT、AUTOSELECT。URI：如果没有，则表示这个tag描述的可选择版本在主PlayList的EXT-X-STREAM-INF中存在;TYPE:AUDIO and VIDEO;GROUP-ID:具有相同ID的MEDIAtag，组成一组样式；LANGUAGE：identifies the primary language used in the rendition。NAME：The value is a quoted-string containing a human-readable description of the rendition. If the LANGUAGE attribute is present then this description SHOULD be in that language。DEFAULT： YES或是NO，默认是No，如果是YES，则客户端会以这种选项来播放，除非用户自己进行选择。AUTOSELECT：YES或是NO，默认是No，如果是YES，则客户端会根据当前播放环境来进行选择（用户没有根据自己偏好进行选择的前提下）。The EXT-X-MEDIA tag appeared in version 4 of the protocol。o All EXT-X-MEDIA tags in the same group MUST have the same TYPEattribute.o All EXT-X-MEDIA tags in the same group MUST have different NAMEattributes.o A group MUST NOT have more than one member with a DEFAULTattribute of YES.o All members of a group whose AUTOSELECT attribute has a value ofYES MUST have LANGUAGE [RFC5646] attributes with unique values.o All members of a group with TYPE=AUDIO MUST use the same audiosample format.o All members of a group with TYPE=VIDEO MUST use the same videosample format。</attribute-list></td></tr><tr><td>#EXT-X-STREAM-INF</td><td style="text-align:left">指定一个包含多媒体信息的 media URI 作为PlayList，一般做M3U8的嵌套使用，它只对紧跟后面的URI有效，格式如下：#EXT-X-STREAM-INF:<attribute-list><uri>有以下属性：BANDWIDTH：带宽，必须有。PROGRAM-ID：该值是一个十进制整数，惟一地标识一个在PlayList文件范围内的特定的描述。一个PlayList 文件中可能包含多个有相同ID的此tag。CODECS：不是必须的。RESOLUTION：分辨率。AUDIO：这个值必须和AUDIO类别的“EXT-X-MEDIA”标签中“GROUP-ID”属性值相匹配。VIDEO：同上</uri></attribute-list></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> -HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -HLS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>19-03-24-了解HLS</title>
      <link href="/HLS/19-03-24-%E4%BA%86%E8%A7%A3HLS/"/>
      <url>/HLS/19-03-24-%E4%BA%86%E8%A7%A3HLS/</url>
      
        <content type="html"><![CDATA[<p>​    HLS 是由苹果公司提出并且进行推广的，我们直接引用一段维基百科的内容:</p><blockquote><p><strong>HTTP Live Streaming</strong>（缩写是<strong>HLS</strong>）是一个由<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8" target="_blank" rel="noopener">苹果公司</a>提出的基于<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/HTTP" target="_blank" rel="noopener">HTTP</a>的<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E6%B5%81%E5%AA%92%E4%BD%93" target="_blank" rel="noopener">流媒体</a><a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">网络传输协议</a>。是苹果公司<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/w/index.php?title=QuickTime_X&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">QuickTime X</a>和<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/IPhone" target="_blank" rel="noopener">iPhone</a>软件系统的一部分。它的工作原理是把整个流分成一个个小的基于HTTP的文件来下载，每次只下载一些。当媒体流正在播放时，客户端可以选择从许多不同的备用源中以不同的速率下载同样的资源，允许流媒体会话适应不同的数据速率。在开始一个流媒体会话时，客户端会下载一个包含元数据的<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/w/index.php?title=Extended_M3U&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">extended M3U (m3u8)</a><a href="https://link.jianshu.com?t=https://zh.wikipedia.org/w/index.php?title=Playlist&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">playlist</a>文件，用于寻找可用的媒体流。<br> HLS只请求基本的HTTP报文，与<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E5%AE%9E%E6%97%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">实时传输协议（RTP)</a>不同，HLS可以穿过任何允许HTTP数据通过的<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E9%98%B2%E7%81%AB%E5%A2%99" target="_blank" rel="noopener">防火墙</a>或者<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E4%BB%A3%E7%90%86%E6%9C%8D%E5%8A%A1%E5%99%A8" target="_blank" rel="noopener">代理服务器</a>。它也很容易使用<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C" target="_blank" rel="noopener">内容分发网络</a>来传输媒体流。<br> 苹果公司把HLS协议作为一个<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/w/index.php?title=Internet-Draft&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener">互联网草案</a>（逐步提交），在第一阶段中已作为一个非正式的标准提交到<a href="https://link.jianshu.com?t=https://zh.wikipedia.org/wiki/IETF" target="_blank" rel="noopener">IETF</a>。但是，即使苹果偶尔地提交一些小的更新，IETF却没有关于制定此标准的有关进一步的动作。</p></blockquote><p>​    </p><p>​    <strong>协议内容：</strong></p><p>​        HLS协议规定：</p><ol><li><p>首先，整个视屏都是TS格式的，一部影片并不是只有一个下载链接，而是有许多的ts文件地址组成；</p></li><li><p>视频的编码格式是H264，音频编码格式是MP3，ACC或者AC-3</p></li><li><p>其次在整个HLS的格式中有个很重要的文件 M3U8(文本文件)，主要是用来控制和记录播放的每个ts地址；</p><p>​        </p><p>​    苹果研究这个协议的主要原因：</p><ol><li>不被频闭：正常的视屏传输都是基于TCP协议的进行传输，这就要求双方都要实时在线，而且在一些特殊网络环境中会将TCP的端口禁掉这就会使是视屏无法播放；</li><li>负载，面对这个问题，HLS因为是基于Http请求的所以就不需要实时在线，服务端需要内容时就直接通过Http协议向server端进行请求下载就可以了；</li><li>码率，又叫比特率，首先对于码率是越高，说明他每秒的传送数据就越多，画质就会越清晰；在回到HLS中，在HLS中对于码率是自适应的，不同带宽的设备可以自动切换到最合适自己的码率的视频播放上。</li><li>缺点：前面说了那么多好处是不是就感觉他完美了呢？其实并不是，在他兼顾了前面的哪些之后在面对实时性这个问题上就不是那么完美了，在和其他协议(例如 RTMP协议)进行比较时在视频延迟方面是有无法跨越的沟，HLS直播的视屏延迟无法到10秒以下，但是RTMP 最低的延迟能够降到 3   4 秒左右；</li></ol></li></ol><p>​    <strong>HLS的index文件—M3U8文件：</strong></p><ol><li><p>如果你下了一个M3U8文件，这是你的同事也下了一个但是你发现你们两个人的文件内容不一样如图：</p><p>A1</p></li></ol><p><img src="/HLS/19-03-24-了解HLS/m3u8一级文件.png" alt="m3u8一级文件"></p><p>A2：</p><p><img src="/HLS/19-03-24-了解HLS/m3u8二级文件.png" alt="m3u8二级文件"></p><p>上面的内容就用A1，和A2表示，A1的格式属于一级文件；A2的格式属于二级文件；</p><p>什么是一级文件，什么是二级文件？</p><p>​    一级文件：如A1在进入页面中直接能够看到以ts结尾的文件路劲名；</p><p>​    二级文件：如A2在进入文件中时并不能直接看到以ts结尾的文件名而是.m3u8的文件名这时候就需要进行一个文件拼接将A1的路劲+A2中所能看到的一级路径，就能得到二级路径，里面就是ts的链接段；</p><p>​    总结: 一级文件能够直接得到ts的文件，但是在二级文件中不能直接得到ts下载连接，只有通过地址拼接才能从一级连接中获得二级连接文件，在二级文件中得到ts下载连接；</p><p>​    <strong>关于播放模式：</strong></p><pre><code>1. 点播VOD：这个是直接得到当前所有的一级文件和二级文件，以及所有的ts文件，这种模式允许服务端访问所有的内容；2. Live 实时生成M3U8和ts文件。它的索引文件一直动态变化，播的时候需要不断下载二级index如果末尾没有#EXT-X-ENDLST，说明他是一个live视屏流；</code></pre><p>以上就是关于HLS总结，如果不足之处希望批评指针；欢迎留言，邮箱如下：</p><p><a href="mailto:jsntwangchenchen@outlook.com" target="_blank" rel="noopener">jsntwangchenchen@outlook.com</a>;</p>]]></content>
      
      
      <categories>
          
          <category> -HLS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -HLS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>c++编译原理</title>
      <link href="/C-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/c-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/"/>
      <url>/C-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/c-%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>​    经过两天的采集，总结决定今天晚上将linux下c++编译器 gcc 编译原理进行一个简单的总结，一个是希望有的知识不单单是会用而且还能够清楚的将内容输出；</p><p>​    <strong>环境和系统：</strong>linux系统 编译器是gcc；</p><p>​    <strong>gcc简介：</strong> gcc(GNU编译器套件[GNU Compiler Collection])，包含C，C++，Objective-C，Fortran，Java，Ada，Go等语言的库；</p><p>​    <strong>相关概念：</strong> 写完代码后如果想要将代码运行都是离不开编译，那编译最主要的就是编辑器的作用了，正常情况下我们会遇到于编译器有关的用例举两个例子：</p><p>​            编译：从严格意义上讲编译就是将高级语言转化为低级语言，通常是指汇编语言甚至是机器代码，</p><p>​            交叉编译：如果代码在同一个平台上(相同的CPU或操作系统)上进行编译，生成代码可以在其他平台上进行执行，这就是交叉编译，</p><p>​            反编译： 是指将里面低级原因或者机器代码转化成高级语言的过程；</p><p>​            语言翻译： 是指将一种语言编写的程序转化成另一中等级和复杂的语言的过程；</p><p>​            语言重写： 将语言表达式转换成另一种形式，以更好的适应特定的任务的过程，比如优化；</p><p>​    <strong>编译流程：</strong> gcc编译  .cpp 文件一共包含四个内容： 预处理，编译，汇编，链接；</p><p>​    <strong>流程图：</strong> </p><p><img src="/C-编译原理/c-编译原理/编译流程图.jpg" alt="编译流程图"></p><p>​    <strong>详细步骤：</strong> </p><p>​            <strong>在处理前有个前提就是以及在编辑器上写好了你的代码 生成了.cpp 和 .h 的文件</strong></p><p>​            1.预处理：</p><p>​                预编译过程主要处理哪些源代码中以#号开始编译的与编译指令，</p><p>​                    将#include 关键字标示的含义有定义的文件(包含文件或者头文件)包含到源代码文件中；</p><p>​                    将 #define 语句指定的值转化成常量；</p><p>​                    在 代码中调用宏的位置将宏定义转化成代码；</p><p>​                    根据 #if #elif #endif 指令的位置包含或者派出特定部分代码；</p><p>​                预处理程序输出的内容就是转换完成的C/C++代码，这些输出的结果会供下一个编译阶段使用，到这部就会生成一个.ii 的文件，但是如果是c代码就会生成一个 .i 的文件；</p><p>​            2.编译：</p><p>​                在编译阶段主要的作用就检查你的语法语义，但是在这之前编译器会先将代码转化成便于处理的形式，主要就是将里面不必要的空格和注释先删掉，然后才是检查你的语法语句，编译器会在检查到不满足语法规则的时候进行报错或者进行警告，就是我们最怕看到的ERROR和</p><p>Warning；具体语法分析逻辑如下：</p><p>​                    词法分析：将原代码分割成不可分割的单词；</p><p>​                    语法分析：将上一步提取出来的单词连接成单词序列，然后根据语言规则验证它是否合理；</p><p>​                    语义分析： 检测上面通过的语法规则又没有实际意义，比如将数赋值给对象，在语法中不会报错但在这里就可能无法通过（除非对象重载了赋值操作符）；</p><p>​            3.汇编阶段：</p><p>​                通过上一层之后，在这一层编译器会将标准的语言集合转化成特定的CPU指令集语言集合；</p><p>​            </p><p>​            4.链接：</p><p>​                通过连接器对程序内存映射提供各种各样的节，并将独立的节组合成最终的程序内存映射节，其中就包括内存的映射和依赖库的映射；</p><p>​    <strong>cmd手动汇编：</strong>    </p><p>​        背景介绍:  已在本地路径编写test.cpp文件,目的是为了编译成可执行程序test.exe；</p><p>​        流程如下：</p><p>​             预处理（进行宏替换）<br>​                     gcc -E test.c -o  test.ii   (只预处理生成一个test.ii文件)<br>​                         1.预处理功能主要包括：宏替换，展开头文件，条件编译，去注释等。<br>​                         2.预处理指令是以#开头的代码行。<br>​                        3.-E：让gcc在与处理结束后停止编译过程。<br>​                         4.-o：指目标文件test.ii已经过预处理的C原始程序。<br>​<br>​             编译（生成汇编）<br>​                     gcc -S test.ii  -o  test.s   (只走到编译阶段生成test.s文件)<br>​                         1.在这个阶段中，gcc首先要检查代码的规范性，是否有语法错误等。以确定代码要做的功工作，在检查无误后，gcc把代码翻译成汇编语言。<br>​                      -S：只进行编译，不进行汇编，生成汇编代码。<br>              汇编 （生成机器可识别代码）<br>​                       gcc -c test.s -o test.o    （test.o计算机已经可以识别但还不可以执行）<br>​                       把编译阶段生成的.s文件转换为目标文件。<br>​                       -c：看到汇编代码以转化为.o的二进制目标代码<br>              链接（生成可执行文件或库文件）<br>​                     gcc test.o -o test.exe  生成最终的exe可执行程序    </p><p>以上就是全部内容如果不足之处欢迎批评指正；</p><p>E-mail  : <a href="mailto:jsntwangchenchen@outlook.com" target="_blank" rel="noopener">jsntwangchenchen@outlook.com</a>;</p><p>​</p>]]></content>
      
      
      <categories>
          
          <category> C++编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo上传的图片在网页上无法显示的解决办法</title>
      <link href="/article/Hexo%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
      <url>/article/Hexo%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%E5%9C%A8%E7%BD%91%E9%A1%B5%E4%B8%8A%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>今天打开博客原想瞅一眼，但是突然发现许多图片都不见了，就是链接不到了，感到很奇怪最后发现了原因，方法如下：</p><p>1.找到<code>Hexo</code>下的<code>_config.yml</code>里的<code>post_asset_folder</code>，把这个选项从<code>false</code>改成<code>true</code>。</p><p><img src="/article/Hexo上传的图片在网页上无法显示的解决办法/配置设置.png" alt="配置设置"></p><p>2.在<code>Hexo</code>目录下打开Git Brsh，执行一个下载上传图片插件的命令<code>npm install hexo-asset-image --save</code>。</p><p><img src="/article/Hexo上传的图片在网页上无法显示的解决办法/install设置.png" alt="install设置"></p><p>3.继续在Git Brsh下利用<code>hexo n &quot;Hexo上传的图片在网页上无法显示的解决办法&quot;</code>来生成md的文件（” “里的内容填自己的文件名），这时就会在同级的目录下生成一个同名的文件夹。</p><p><img src="/article/Hexo上传的图片在网页上无法显示的解决办法/开篇.png" alt="开篇"></p><p>6.最后再提交一下</p><p><img src="/article/Hexo上传的图片在网页上无法显示的解决办法/提交.png" alt="提交"></p><p>这样就解决了，最后要感谢  <a href="https://blog.csdn.net/qq_38148394/article/details/79997971" target="_blank" rel="noopener">https://blog.csdn.net/qq_38148394/article/details/79997971</a>  袍子情书童鞋给的提示；</p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>密码学关键总结指南</title>
      <link href="/article/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%B3%E9%94%AE%E6%80%BB%E7%BB%93/"/>
      <url>/article/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%85%B3%E9%94%AE%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>在上一章，我介绍了密码学的来龙去脉，这一章将会围绕对称加密和非对称加密进行原理的分析，且，各举一个工作算法对它们的工作原理进行一些简单的解析；</p><h4 id="1-对称加密"><a href="#1-对称加密：" class="headerlink" title="1. 对称加密："></a><strong>1. 对称加密：</strong></h4><p>​    对称加密主要有三种： AES  DES  IDEA ，今天就主要讲下AES  的工作原理和解密方式；</p><h5 id="11-aes算法"><a href="#1-1-AES算法" class="headerlink" title="1.1 AES算法: "></a><strong>1.1 AES算法: </strong></h5><h5 id="111-aes-加密"><a href="#1-1-1-AES-加密：" class="headerlink" title="1.1.1 AES 加密："></a><strong>1.1.1 AES 加密：</strong></h5><p>​        DES算法的入口参数有三个：Key、Data、Mode。其中Key为8个字节共64位，是DES算法的工作密钥；Data也为8个字节64位，是要被加密或被解密的数据；Mode为DES的工作方式，有两种：加密或解密。</p><p>​          DES算法把64位的明文输入块变为64位的密文输出块，它所使用的密钥也是64位，整个算法的主流程图如下：</p><p>​        其功能是把输入的64位数据块按位重新组合，并把输出分为L0、R0两部分，每部分各长32位，其置换规则见下表：<br>58,50,12,34,26,18,10,2,60,52,44,36,28,20,12,4,<br>62,54,46,38,30,22,14,6,64,56,48,40,32,24,16,8,<br>57,49,41,33,25,17, 9,1,59,51,43,35,27,19,11,3,<br>61,53,45,37,29,21,13,5,63,55,47,39,31,23,15,7,<br>​        即将输入的第58位换到第一位，第50位换到第2位，…，依此类推，最后一位是原来的第7位。L0、R0则是换位输出后的两部分，L0是输出的左32位，R0 是右32位，例：设置换前的输入值为D1D2D3……D64，则经过初始置换后的结果为：L0=D58D50…D8；R0=D57D49…D7。<br>​        经过16次迭代运算后。得到L16、R16，将此作为输入，进行逆置换，即得到密文输出。逆置换正好是初始置的逆运算，例如，第1位经过初始置换后，处于第40位，而通过逆置换，又将第40位换回到第1位，其逆置换规则如下表所示：<br>40,8,48,16,56,24,64,32,39,7,47,15,55,23,63,31,<br>38,6,46,14,54,22,62,30,37,5,45,13,53,21,61,29,<br>36,4,44,12,52,20,60,28,35,3,43,11,51,19,59,27,<br>34,2,42,10,50,18,58 26,33,1,41, 9,49,17,57,25,<br>放大换位表<br>32, 1, 2, 3, 4, 5, 4, 5, 6, 7, 8, 9, 8, 9, 10,11,<br>12,13,12,13,14,15,16,17,16,17,18,19,20,21,20,21,<br>22,23,24,25,24,25,26,27,28,29,28,29,30,31,32, 1,<br>单纯换位表<br>16,7,20,21,29,12,28,17, 1,15,23,26, 5,18,31,10,<br>2,8,24,14,32,27, 3, 9,19,13,30, 6,22,11, 4,25,<br>​        在f(Ri,Ki)算法描述图中，S1,S2…S8为选择函数，其功能是把6bit数据变为4bit数据。下面给出选择函数Si(i=1,2……8)的功能表：<br>选择函数Si<br>S1:<br>14,4,13,1,2,15,11,8,3,10,6,12,5,9,0,7,<br>0,15,7,4,14,2,13,1,10,6,12,11,9,5,3,8,<br>4,1,14,8,13,6,2,11,15,12,9,7,3,10,5,0,<br>15,12,8,2,4,9,1,7,5,11,3,14,10,0,6,13,<br>S2:<br>15,1,8,14,6,11,3,4,9,7,2,13,12,0,5,10,<br>3,13,4,7,15,2,8,14,12,0,1,10,6,9,11,5,<br>0,14,7,11,10,4,13,1,5,8,12,6,9,3,2,15,<br>13,8,10,1,3,15,4,2,11,6,7,12,0,5,14,9,<br>S3:<br>10,0,9,14,6,3,15,5,1,13,12,7,11,4,2,8,<br>13,7,0,9,3,4,6,10,2,8,5,14,12,11,15,1,<br>13,6,4,9,8,15,3,0,11,1,2,12,5,10,14,7,<br>1,10,13,0,6,9,8,7,4,15,14,3,11,5,2,12,<br>S4:<br>7,13,14,3,0,6,9,10,1,2,8,5,11,12,4,15,<br>13,8,11,5,6,15,0,3,4,7,2,12,1,10,14,9,<br>10,6,9,0,12,11,7,13,15,1,3,14,5,2,8,4,<br>3,15,0,6,10,1,13,8,9,4,5,11,12,7,2,14,<br>S5:<br>2,12,4,1,7,10,11,6,8,5,3,15,13,0,14,9,<br>14,11,2,12,4,7,13,1,5,0,15,10,3,9,8,6,<br>4,2,1,11,10,13,7,8,15,9,12,5,6,3,0,14,<br>11,8,12,7,1,14,2,13,6,15,0,9,10,4,5,3,<br>S6:<br>12,1,10,15,9,2,6,8,0,13,3,4,14,7,5,11,<br>10,15,4,2,7,12,9,5,6,1,13,14,0,11,3,8,<br>9,14,15,5,2,8,12,3,7,0,4,10,1,13,11,6,<br>4,3,2,12,9,5,15,10,11,14,1,7,6,0,8,13,<br>S7:<br>4,11,2,14,15,0,8,13,3,12,9,7,5,10,6,1,<br>13,0,11,7,4,9,1,10,14,3,5,12,2,15,8,6,<br>1,4,11,13,12,3,7,14,10,15,6,8,0,5,9,2,<br>6,11,13,8,1,4,10,7,9,5,0,15,14,2,3,12,<br>S8:<br>13,2,8,4,6,15,11,1,10,9,3,14,5,0,12,7,<br>1,15,13,8,10,3,7,4,12,5,6,11,0,14,9,2,<br>7,11,4,1,9,12,14,2,0,6,10,13,15,3,5,8,<br>2,1,14,7,4,10,8,13,15,12,9,0,3,5,6,11,<br>​        在此以S1为例说明其功能，我们可以看到：在S1中，共有4行数据，命名为0，1、2、3行；每行有16列，命名为0、1、2、3，……，14、15列。<br>现设输入为： D＝D1D2D3D4D5D6<br>令：列＝D2D3D4D5<br>行＝D1D6<br>​        然后在S1表中查得对应的数，以4位二进制表示，此即为选择函数S1的输出。下面给出子密钥Ki(48bit)的生成算法<br>​        从子密钥Ki的生成算法描述图中我们可以看到：初始Key值为64位，但DES算法规定，其中第8、16、……64位是<a href="https://www.baidu.com/s?wd=%E5%A5%87%E5%81%B6%E6%A0%A1%E9%AA%8C%E4%BD%8D&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">奇偶校验位</a>，不参与DES运算。故Key 实际可用位数便只有56位。即：经过缩小选择换位表1的变换后，Key 的位数由64 位变成了56位，此56位分为C0、D0两部分，各28位，然后分别进行第1次循环左移，得到C1、D1，将C1（28位）、D1（28位）合并得到56位，再经过缩小选择换位2，从而便得到了密钥K0（48位）。依此类推，便可得到<a href="https://www.baidu.com/s?wd=K1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">K1</a>、K2、……、<a href="https://www.baidu.com/s?wd=K1&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">K1</a>5，不过需要注意的是，16次循环左移对应的左移位数要依据下述规则进行：<br>循环左移位数<br>1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1  </p><p><strong>AES加密流程图：</strong></p><p>​            <img src="/article/密码学关键总结/DES加密流程图.png" alt="DES加密流程图"></p><p>​        <strong>1.1.2 AES 解密：</strong></p><p>​        DES解密用的函数和加密使用的是同一个函数所以就直接将k依次代入进去（反序）就好，比如之前是 k1，k2，k3，…….k16, 那解密就是 k16, k15, k14……k1;</p><h4 id="2-非对称加密"><a href="#2-非对称加密：" class="headerlink" title="2. 非对称加密："></a><strong>2. 非对称加密：</strong></h4><p>非对称加密，主要有三个 RSA Elgamal 及椭圆曲线密码体制； 并将对RSA的工作原理进行简单的说明；</p><h5 id="21-rsa-密钥对的产生"><a href="#2-1-RSA-密钥对的产生：" class="headerlink" title="2.1 RSA 密钥对的产生："></a><strong>2.1 RSA 密钥对的产生：</strong></h5><p>​    选择两个大素数，p和q 计算： </p><p>​            n = pq</p><p>​    然后随机选择加密密钥e，要求e 和(p-1)(q-1)互素，最后，利用欧几里得算法计算解密密钥d，使其满足：</p><p>​            ed = 1mod[(p-1)(q-1)]</p><p>​    最后数 e和n是公钥，d是私钥，两个素数p和q不在需要，应该丢弃不让任何人知道；</p><h5 id="22-rsa加密"><a href="#2-2-RSA加密：" class="headerlink" title="2.2 RSA加密："></a><strong>2.2 RSA加密：</strong></h5><p>​    对消息m(长度小于或等于n，否则，首先把m分成若干个数据块)    加密时，对应的密文是：</p><p>​            C = m e(mod n);</p><h5 id="23-rsa-解密"><a href="#2-3-RSA-解密：" class="headerlink" title="2.3 RSA 解密："></a><strong>2.3 RSA 解密：</strong></h5><p>​    为解密密文c做如下计算：</p><p>​            m = c d（mod n）；</p><p>​    如果第三者进行窃听就，他必须要想办法得到几个数：m n(=pq),e,如果要解密就要先得到d，所以先对n，做质因数分解，要防止他分解成功，最有效的方法是找两个非常大的质数，是第三者做因素分解是发生可困难；</p><h4 id="3-pki技术"><a href="#3-PKI技术" class="headerlink" title="3. PKI技术"></a><strong>3. PKI技术</strong></h4><p>PKI是Public Key Infrastructure的首字母缩写，翻译过来就是公钥基础设施；PKI是一种遵循标准的利用公钥加密技术为电子商务的开展提供一套安全基础平台的技术和规范。</p><h5 id="31-pki组成部分"><a href="#3-1-PKI组成部分" class="headerlink" title="3.1 PKI组成部分"></a><strong>3.1 PKI组成部分</strong></h5><p>​    PKI的基础技术包括加密、数字签名、数据完整性机制、数字信封、双重数字签名等。一个典型、完整、有效的PKI应用系统至少应具有以下部分：</p><p>· 公钥密码证书管理。</p><p>· 黑名单的发布和管理。</p><p>· 密钥的备份和恢复。</p><p>· 自动更新密钥。</p><p>· 自动管理历史密钥。</p><p>· 支持交叉认证。</p><p>认证机构（CA）：即数字证书的申请及签发机关，CA必须具备权威性的特征；</p><p>数字证书库：用于存储已签发的数字证书及公钥，用户可由此获得所需的其他用户的证书及公钥；</p><p>密钥<a href="https://baike.baidu.com/item/%E5%A4%87%E4%BB%BD" target="_blank" rel="noopener">备份</a>及恢复系统：如果用户丢失了用于解密数据的密钥，则数据将无法被解密，这将造成合法数据丢失。为避免这种情况，PKI提供备份与恢复密钥的机制。但须注意，密钥的备份与恢复必须由可信的机构来完成。并且，密钥备份与恢复只能针对解密密钥，签名私钥为确保其唯一性而不能够作备份。</p><p>证书作废系统：证书作废处理系统是PKI的一个必备的组件。与日常生活中的各种身份证件一样,证书有效期以内也可能需要作废，原因可能是密钥介质丢失或用户身份变更等。为实现这一点,PKI必须提供作废证书的一系列机制。</p><p>应用接口（<a href="https://baike.baidu.com/item/API" target="_blank" rel="noopener">API</a>）：PKI的价值在于使用户能够方便地使用加密、数字签名等安全服务，因此一个完整的PKI必须提供良好的应用接口系统，使得各种各样的应用能够以安全、一致、可信的方式与PKI交互，确保安全网络环境的完整性和易用性。</p><p>通常来说，CA是证书的签发机构,它是PKI的核心。众所周知，构建密码服务系统的核心内容是如何实现密钥管理。公钥体制涉及到一对密钥（即私钥和公钥），私钥只由用户独立掌握，无须在网上传输，而公钥则是公开的，需要在网上传送，故公钥体制的密钥管理主要是针对公钥的管理问题，时下较好的解决方案是数字证书机制。</p><h5 id="32-pki应用场景"><a href="#3-2-PKI应用场景：" class="headerlink" title="3.2 PKI应用场景："></a><strong>3.2 PKI应用场景：</strong></h5><p>​    Bob和Alice需要通信前面有提过，由Alice将自己的公钥发给Bob,然后Bob利用Alice的公钥加密明文，在将内容传回给Alice，这样看起来很完美，Evn即使拿到内容在没有Alice的私钥的情况下也不可能解密，但是，Evn比较狡猾，她将Alice发个Bob的公钥截获了，并换上自己的公钥，可是Bob并不知情，Alice也不知情，那它们之间的通信也就不在安全了，那怎样确定Bob拿到的公钥是Alice的公钥呢，这时候就需要一个专业的公正的机构站出来，那所有人的公钥都交由这个机构管理，我们叫它CA，如果Bob需要Alice的公钥时直接去向CA请求，CA收到请求后会会将，Alice的公钥用自己的私钥加密在发给Bob，这样Bob利用CA公开在自己网站上自己的公钥就能够得到Alice的正确公钥；这个利用CA的技术就是PKI技术；</p><h4 id="4-签名和散列"><a href="#4-签名和散列" class="headerlink" title="4. 签名和散列"></a><strong>4. 签名和散列</strong></h4><h5 id="41-签名使用场景"><a href="#4-1-签名使用场景：" class="headerlink" title="4.1 签名使用场景："></a><strong>4.1 签名使用场景：</strong></h5><p>​    •签名是非对称加密的一种应用。使用私钥加密数据，就是对数据的签名</p><p>​    •签名是将数据通过运算后得到签名信息，被签名的数据发生不论什么改变哪怕这样的改变很细微，也无法获得相同的签名信息。</p><p>​    同样是上面的Bob和Evn通信，防止Evn窃听，这时Bob已经拿到了Alice的公钥对自己的内容进行加密，但是他还是担心Evn会自己有Alice的公钥替换掉他的信，于是他就在写完信后，将整个信利用HASH算法进行了编译(HASH算法编译出来的内容不能在反编回去，而且一但原文有任何细小的变化那再生成的HASH和之前的比都天差地别)；在将这个算出来的Hash用自己的私钥进行加密，这个就是签名；最后交给了Alice，Alice拿到信后去CA取到了Bob的公钥，先将签名解密得到Hash，得到后将Bob的信进行Hash运算，然后将两个Hash进行比较，如果一样就说明Bob的信是没有人改变过，而且也能确定是Bob本人发的；</p><h5 id="42-什么是散列常用的是什么"><a href="#4-2-什么是散列常用的是什么：" class="headerlink" title="4.2 什么是散列常用的是什么："></a><strong>4.2 什么是散列常用的是什么：</strong></h5><p>​    •就是把随意长度的输入（又叫做预映射），通过散列算法，变换成固定长度的输出。该输出就是散列值。这样的转换是一种压缩映射。也就是。散列值的空间通常远小于输入的空间，不同的输入可能会散列成同样的输出，而不可能从散列值来唯一的确定输入值。简单的说就是一种将随意长度的消息压缩到某一固定长度的消息摘要的函数。</p><p>​    •常用的散列算法：SHA-1 , SHA-256、MD5 , MD2     </p><p>​    特点：</p><p>​    •无法反向运行散列算法恢复最初的明文</p><p>​    •得到的摘要不会告诉不论什么关于最初明文的信息</p><p>​    •同一明文用同一散列算法，生成后的值唯一</p><p>以上就是我整理的关于密码学的所有知识，如果有理解不对的地方希望大家能够提出来，我也会切实的去修改；</p><p>邮箱：<a href="mailto:jsntwangchenchen@outlook.com" target="_blank" rel="noopener">jsntwangchenchen@outlook.com</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>密码学理论基础指南</title>
      <link href="/article/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/"/>
      <url>/article/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%90%86%E8%AE%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>​    在过去的一年中因为工作需要接触了密码学相关的知识，现在开一篇文章从六个点对密码学做个简单的概括总结：</p><p>在开始之前先感谢几位老师，有的是在工作中对我悉心指导，有的是发表的书籍，还有的一些网络课程很生动如下: Philips  researcher 葛博士，在最初的时候耐心讲解和指导尤其在项目应用上，《密码学基础与安全应用》的各位作者，在里面找到了很多答案，《得到-密码学30奖》作者 卓客老师，文中的历史方面的卓老师给了很好的答案；</p><h4 id="1-历史介绍"><a href="#1-历史介绍" class="headerlink" title="1. 历史介绍"></a><strong>1. 历史介绍</strong></h4><p>​        通过历史，总体的来说密码学可以分为两部分来看，一部分是在计算计出来之前叫做<strong>古典密码学</strong>,之后的就叫做<strong>现代密码学</strong>；</p><p>​        其实不管是古代还是现代都有一条关键的主线，那就是加密和解密；它们一直都在迭代，此消彼长，有的时候任何加密都不保险，有的时候任何解密都没有效果；</p><p>​        密码大致被分为七个阶段分别为：</p><p>​        <strong>隐藏法，移位发/替代法，维吉尼亚密码，恩尼格玛机(Enigma)，魔王加密系统(Lucifer)</strong></p><p>​        第一代和第二代时间跨度较长花费了4500年，但从第三代开始迭代就开始变快，从第四代开始出现了钥匙的概念，而钥匙就是最重要的突破口；从第五代开始出现计算机分水岭就这样产生了，</p><p>​        <strong>RSA加密系统   量子加密</strong></p><p>​        70年代末，第六代RSA加密系统出现了，它就是目前互联网加密的底层，它解决了第五代中的漏洞，虽然它并不是无法破解的，但因为计算量太大，在理论上破解的时间是无限长；第七代量子加密，背后的理论支撑是测不准原理和特殊的 ，在物理学和数学的原理上是不可破解的；</p><h5 id="11-隐藏法的特征"><a href="#1-1-隐藏法的特征：" class="headerlink" title="1.1 隐藏法的特征："></a><strong>1.1 隐藏法的特征：</strong></h5><p>​        这段是最古老密码学开端，就是将新建藏匿；</p><h5 id="12-移位法的特征"><a href="#1-2-移位法的特征：" class="headerlink" title="1.2 移位法的特征："></a><strong>1.2 移位法的特征：</strong></h5><p>​        密文的内容是在原文的基础上，对里面的字母进行向前或者向后移位的，最后形成的就是只有加密者自己能看懂了，这个还包含个故事：16世纪苏格兰女王玛丽一世，被她的姑姑英格兰女王伊丽莎白一世关押18年，在狱里的玛丽和反叛军都想杀伊丽莎白于是之间传递信息就是用的移位法，但是玛丽身边有个双面间谍，所以每次的信都是被伊丽莎白截获送到当时的密码学校在破译好了在交给玛丽但是后面可想而知玛丽最后被杀了；但在这之中密码学校所使用的解密方法就是频率分析法，利用的就是英文中字母的使用频率是不一样的，通过不最高的频率确定一个点在确定一个单词接着一句话；</p><p>下面放三张图一张是玛丽的密信及原文，一张是字母的使用频率，最后是一些其他语言的使用频率；</p><p><strong>玛丽使用密文及原文：</strong></p><p><img src="/article/密码学理论总结/玛丽女王使用密码的原文和密文.png" alt="玛丽女王使用密码的原文和密文"></p><p><strong>英语使用频率：</strong></p><p><img src="/article/密码学理论总结/英语中字母频率统计.png" alt="英语中字母频率统计"></p><p><strong>各语言中字母排列统计：</strong></p><p><img src="/article/密码学理论总结/各语言中字母排列统计.png" alt="各语言中字母排列统计"></p><h5 id="13-维吉尼亚加密法特征"><a href="#1-3-维吉尼亚加密法特征：" class="headerlink" title="1.3 维吉尼亚加密法特征："></a><strong>1.3 维吉尼亚加密法特征：</strong></h5><p>​        这个还要说到第二代替换和移位加密法的漏洞，就是能够计算出字母的使用频率，于是就出现了“多套符号加密法”为了掩盖字母使用中暴露的频率特征，解决办法就是用多套符号代替原来的文字，比如原文字母A 以前只是把它替换成H，现在把它替换成H或J，至于什么时候换H 什么时候换J，可以自己规定，比如基数位换H 偶数位换J；多套符号加密法并没有满足2-3套，经典一共有26套，而这26套加密的就是维吉尼亚加密法；会制定一个钥匙，比如yes y 是第25个字母，把原文第一个向后移25个，第二个是5个就向后移5个这样即使相同的字母就会得到不同的结果；</p><p><strong>维吉尼亚密码表：</strong></p><p>​    第一行是原文，下面每一列表示每个字母有几个字符来替换，一共26*26；</p><p><img src="/article/密码学理论总结/维吉尼亚密码表.png" alt="维吉尼亚密码表"></p><h5 id="14-恩尼格玛机加密法特征"><a href="#1-4-恩尼格玛机加密法特征：" class="headerlink" title="1.4 恩尼格玛机加密法特征："></a><strong>1.4 恩尼格玛机加密法特征：</strong></h5><p>​        恩尼格玛机，相信有一些小伙伴已经听过了，在二战时这个还比较出名，也是被图灵破译的那个，它使用的加密方式本质还是第二代加密法，移位和替换，它是一种机械电子式加密机，由一堆齿轮，电线灯泡转盘和遥杆组成，通过对抗无穷多的加密配套组合，能有效对抗频率分析；机器分三部分，键盘，编码器（原文-&gt;密文），屏幕显示密文；</p><p>​        编码器：硬件是由一堆可以手动设置的机械部件组成的，任何地方调整都可以改便加密结果；里面有个齿轮式字母盘，齿轮和键盘还有屏幕利用导线连接，输入明文后齿轮直接得到密文显示在屏幕上，关键是每加密一个字母齿轮会自动向下转一格，齿轮每转动一格表示换一套加密方法，战时最高标准是8套，附图：</p><p><strong>恩尼格玛机三组齿轮：</strong></p><p><img src="/article/密码学理论总结/三组齿轮的恩尼格玛机.png" alt="三组齿轮的恩尼格玛机"></p><p><strong>恩尼格玛机八组齿轮：</strong></p><p><img src="/article/密码学理论总结/八组齿轮的恩尼格玛机.png" alt="八组齿轮的恩尼格玛机"></p><p>​    </p><p>​        <strong>1.5 魔王加密系统特征：</strong></p><p>​        是不是觉得名字很有意思，其实它原来的名字叫做Demostration（示范算法）；但当时70年代对操作系统名字有限制，只能取Demo，而demo又是”恶魔”的意思后来大家就用另一个恶魔的名字Lucifer 也就是魔王来称呼了，从魔王开始，就不在是操作字母了而是数字并且使用上了机器，不是再像以前一样是用的笔和本子； 在这个算法中有个比较重要的几个人IT虚拟人物分别是 Alice(爱丽丝) Bob(鲍勃) Eve(伊芙)希望你能记住，我将会用它们的来解释信息加密后钥匙安全是怎么保证的；</p><p>​        主体是利用数学上的“模运算”(modelar arithmetic),它有时是不可逆的操作，大概意思如下：2+3 =5（mod7）；但11* 9=8(mode13);正向可以推但是如果反向，什么数乘9余数是8，相信这个数是无穷大的；具体的过程是这样的 Alice和Bob事先约定一个函数(不可逆函数)和模数，在加密前两人各自想一个数字通过函数计算得到结果，两人在打电话将自己的结果告诉对方，拿到对方的答案后将答案带入到函数中这时它们算出的结果就是同一个数了，这个数就是它们共同的密钥；</p><p>​        例子：约定函数：7^X ，模等于11的情况下运行； Alice 想的数 A 是 3   代入函数算出的 P，Bob 想的数是 B 是 6 代入函数算出的是 R； 相互交换 Alice 计算 R ^ A(mod11)  Bob 计算 P^B(mod11);最后两人得出的结论都是九，就可以用九做key；  （上面的方法就是 sun 高级工程师 Whitifield  Diffie和 斯坦福电子系统教授 Martin Hellman 找出的函数，因此这套方法称为 “迪菲 - 黑尔曼钥匙交换方案”）；</p><h5 id="16-rsa加密算法特征"><a href="#1-6-RSA加密算法特征：" class="headerlink" title="1.6 RSA加密算法特征："></a><strong>1.6 RSA加密算法特征：</strong></h5><p>​        好了，下面就开始这篇blog最核心的理论 第六代加密法，RSA加密算法；当然在这段还是介绍它的大概原理里面的具体组成和衍生出的算法我将在下面一段重点进行描述；</p><p>​        在说RSA之前还是得说魔王加密的缺点，这个就是要求双方同时在线才能启动，而现实中我的微信，短信，邮件都是不用对方立刻回复的，这个问题不解决这套方法就没有办法商用；为了解决这个问题就产生了第六代加密系统 RSA加密系统；</p><p>​        可能有的朋友对这个会对RSA有点陌生，其实它现在已经在我们的生活中无处不在了，比如手机支付加密，网银加密，网络的底层也都是这套原理；</p><p>​        具体过程：我们还是用上面三个IT虚拟人物进行讲解，Alice 和 Bob 通信 但是Even 想要窃听；</p><p>​        例子：Alice 有很多把锁，每把锁都有两把不同的钥匙分别是:一把给自己的，除自己外，任何都不能拿到(private key,CK)，而另一把是给一个或多个通信对象的(public key PK) ；这两把钥匙都不能解开自己上的锁，但是都能用自己的钥匙解开对方钥匙上的锁； 她想和Bob通话就将提前将 PK 给 Bob，Bob拿到PK 后将想写的话放到盒子里然后直接将盒子传给Alice，用自己的CK将盒子打开就能得带Bob的内容了；在这里使用的加密和解密的钥匙不是同一个而是分开的这种加密方式叫做”非对称加密”，而采用同一个钥匙进行加解密的属于“对称加密”；</p><h5 id="17-量子加密法"><a href="#1-7-量子加密法：" class="headerlink" title="1.7 量子加密法："></a><strong>1.7 量子加密法：</strong></h5><p>​        最后一个量子加密，有兴趣的童鞋可以查阅相关资料，这里就不做解释；</p><h4 id="2密码系统的组成"><a href="#2-密码系统的组成：" class="headerlink" title="2.密码系统的组成："></a><strong>2.密码系统的组成：</strong></h4><p>​    上面对密码学的历史做了大概的介绍，下面向大家介绍密码系统的组成部分，主要有以下的内容组成的，分别是未加密的消息也称明文(MP)，加密后的消息也称作密文(C)，加密的设备或者加密的算法(D()/E())，最后以及加密解密的密钥(PK/CK)；</p><p>​    结合上面的内容对加密和解密利用简单的数学公式表示：</p><p>​        没有密钥时加密可以表示为：</p><p>​            加密：E(MP)  = C  其中E()表示加密的函数； </p><p>​            解密：D(C) = MP  其中 D()表示解密的函数；</p><p>​        对称密钥，加密解密只用同一个密钥时表示为：</p><p>​            加密：E k(MP) = C  其中k表示钥匙；</p><p>​            解密：D k(C) = MP </p><p>​        非对称密钥，加密解密不是同一个密钥时表示为：</p><p>​            加密：E pk（MP） = C   其中pk指公钥；</p><p>​            解密：D ck（sk） = MP 其中ck指私钥；</p><h5 id="21什么是算法"><a href="#2-1-什么是算法：" class="headerlink" title="2.1.什么是算法："></a><strong>2.1.什么是算法：</strong></h5><p>​        密码算法是指用于加密和解密的数学函数(通常情况下，有两个相关的函数中一个用作加密，另一个用作解密)，在历史上都是通过对算法的保密从而增强生成密码的安全性，但在现在中这样的模式肯定是不安全的，所以现在的算法方式都是公开的，所有人都可以看到，但是通过传入安全的钥匙就可以生成安全的密文，这个才是现在主流使用的；</p><p>​        <strong>2.2 什么是协议：</strong> </p><p>​        如果一个加密算法必须由多个(多余两个) 实体共同参加才能完成，则称之为密码协议，如果一组规则仅有一个实体执行，则它的只是一种程序，而不能称之为协议；除了提供机密性外密码学还拥有一下作用：1. 鉴别，消息的接收着应该能够确认消息的来源，入侵者不可能伪装成他人；2. 完整性检验，消息的接收者应该能够在传送过程中消息没有被修改；入侵者不可能用假消息代替合法消息；3.抗抵赖，发送者一旦发送消息，事后不可能虚假地否认他曾经发送的消息；</p><p>以上就是密码学的历史轨道，以及对密码学大概有一定的了解，下一篇我将会对密码学中的 对称加密，非对称加密，各举一个常用的例子向大家介绍它们的工作原理，并且对，PKI，签名的概念进行讲解，最后在对两个密码学的框架 SSH SSL ,中的其中一个进行简单讲解；</p>]]></content>
      
      
      
        <tags>
            
            <tag> encryption </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[unity3D+3DMAX]下载安装使用指南</title>
      <link href="/unity3D-3DMax%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/unity3D-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/"/>
      <url>/unity3D-3DMax%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/unity3D-%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h6 id="概述"><a href="#概述：" class="headerlink" title="概述："></a>概述：</h6><p>​    1.下载安装unity3D</p><p>​    2.下载安装JavaJDK</p><p>​    3.下载安装AndroidSDK</p><p>​    4.下载安装NDK</p><p>​    5.在unity3D中将2-4安装的地址在制定位置连接上[最重要的一步]</p><p>​    6.3DMax下载安装</p><p>​    7.3DMax基本使用</p><p>​    8.3DMax 创建一个移动的物体</p><p>​    9.将移动的物体成功导入到unity中。</p><h6 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h6><p>​    可直接进入unity3d官网下载最新的版本，点击download，进入到选择界面在进入后选择免费试用版，下面的参考的下载链接。</p><p><a href="https://store.unity.com/cn/download?ref=personal" target="_blank" rel="noopener">unity3D官方下载地址</a></p><p>​    首先双击打开安装包之后直接在前面两个直接“NEXT”在进入选择安装插件一栏中将Vuforia是下面AR专用的包，如果你不是AR项目则是按照自己的实际情况进行选择，后面步骤都是next一直到finish（中途需要选择项目存储路径的就按照自己的节奏来）。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/unity安装选择.png" alt="unity安装选择"></p><p>​    JDK，SDK，NDK下载：</p><p>​        jdk安装就不做累述下面找到个连接说的很详细给大家参考，鉴于oracle开始收费所以个人在个人网盘里保存了一份包括下面SDK,NDK</p><p>​        <a href="https://blog.csdn.net/Bao_Yaun/article/details/64132823" target="_blank" rel="noopener">jdk安装步骤指南</a></p><p>​        <a href="https://pan.baidu.com/s/1rCXNUmQVXcAGhdYiqsMajQ" target="_blank" rel="noopener">jdk-1.8-Windows-64安装包</a></p><p>​        <a href="https://pan.baidu.com/s/1lE62GHq5h5iBvW8I832_IA" target="_blank" rel="noopener">SDK NDK-windows-64-安装文件</a></p><p>​        下面就是将从网盘中下载的文件放到一个路径下（jdk需要安装，SDK和NDK是安装好的文件直接放就好）</p><p>在unity中指定上面安装好的路径，下面就可以用了，</p><p>​    首先打开上面安装好的unity，工具栏中点击Edit-&gt;preference-&gt;external tools在下面的android选项中将自己安装的地址指定就好了。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/unity指定相关连接.png" alt="unity指定相关连接"></p><p>当到这里的时候一个unity就已经安装好了并且你也可以开始制作一个属于自己的AR项目，如果想了解一个基础的AR项目的使用情况，可以出门左转在XR下面还有一篇关于u3D的实际操作。    </p><p>由于我们的目的是为了在3Dmax中创建动态模型然后可以在unity中直接使用所以我们下面就来直接进行到3DMax这一块；</p><p>​    下载安装3DMax</p><p>​        <a href="https://www.autodesk.com.cn/products/3ds-max/overview" target="_blank" rel="noopener">3DMax 下载官网</a></p><p>​            在进入官网时需要用自己的邮箱注册一下才能使用，试用版试用是30天官网评判标准是邮箱；另外在下载时需要注意自己c盘空间因为3DMax下载是exe文件直接点开他自动安装并且路径固定。</p><p>​    安装直接一路“next”就好，最后你进入3DMax会看到这样的图片，有四个部分组成分别是顶视图，前视图，和左视图，还有个透视图</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/首次进入unity界面.png" alt="首次进入unity界面"></p><p>首先创建二维的平面图形轮廓，右侧工具栏加号-&gt;平面-&gt;线，由点连成一条条的线，注意线不能出现交叉，而且还要合上如图：</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/创建一个二维箭头.png" alt="创建一个二维箭头"></p><p>当一个二维轮廓建好之后就需要建一个三维的体，点击加号后面一个视图-&gt;编辑器-&gt;挤出</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/修改为三维.jpg" alt="修改为三维"></p><p>通过对参数中数量的修改就可以改便物体的厚度</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/修改厚度.jpg" alt="修改厚度"></p><p>这样就生成了一个三维的图形下一步就将这个里面的图形动起来做成一个动画，下方工具-&gt;先选定目标，点击自动/手动设置关节点开始记录当前对象的地理位置，移动对象改变对象的地理坐标，通过在不同的时间轴坐标中的时间和对应的对象的地理坐标就可以得到一个按照自己轨迹运动的动画。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/将物体运动.jpg" alt="将物体运动"></p><p>下面就是将这个文件导出准备放到unity3D中进行数据集和模型的结合，首先在上方工具栏-&gt;文件-&gt;导出-&gt;导出-&gt;选定指定的文件地址就可以了。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/将文件导出为FBX格式.jpg" alt="将文件导出为FBX格式"></p><p>走到这里就说明3DMAX这个步骤中已经结束了。</p><p>下面你主要做的就是将里面导入到unity中并且要保证能够有动画效果的，如果直接放进项目是只有模型没有动作的如果相加一些动作是要在加一下设置的操作如下：</p><p>​    将之前导出的FBX文件直接直接放在Assets的目录-&gt;点击文件-&gt;右侧inspector-&gt;Rig-&gt;Animation Type 选择Legacy -&gt;Animation WrapMode选择Loop（上下两个都选）-&gt;单击文件-&gt;Apply就可以导入动图了。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/动图Rig.jpg" alt="动图Rig"></p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/动图Animation.jpg" alt="动图Animation"></p><p>到这里就能显示一个带有固定动作的AR小程序；</p><p>​    下面说一个题外话，我在做demo’的时候有遇到要将一张图片转换成显示的图像也一起来和大家分享一下，首先我的图像是一个png的普通图片并且做过一个处理将背景全部透明，由于直接将图片放在程序中所以就需要在设置上做一写改便首先是将本地的图片导入到Assets中-&gt;单击-&gt;进入Inspector-&gt;将Texture Type 切换成 Sprite(2D and UI)-&gt;图片就可以在程序里面显示了。</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/图片转换.jpg" alt="图片转换"></p><p>下面直接就可以play-&gt;build就可以生成一个apk文件直接安装在手机里了，如果你之前没有成功生成apk文件过您可以出门右转我有一篇<a href="http://jswangchenchen.com/VR-AR%EF%BC%9B-Vuforia%EF%BC%9B-Unity3D/[U3D+Vuforia+VR%E7%9C%BC%E9%95%9C]%E5%88%86%E5%B1%8F%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/" target="_blank" rel="noopener">《[U3D+Vuforia+VR眼镜]分屏设置指南》</a>里面有详细的过程可以参考。我生成的结果如下；</p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/成果1.jpg" alt="成果1"></p><p><img src="/unity3D-3DMax下载安装指南/unity3D-下载安装指南/成果2.jpg" alt="成果2"></p><p>如有不足之处多多指教。</p>]]></content>
      
      
      <categories>
          
          <category> unity3D+3DMax下载安装指南; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[GithubPage+Hexo+域名]免费博客搭建指南</title>
      <link href="/GithubPage-hexo/Github-Hexo-%E5%9F%9F%E5%90%8D-%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/"/>
      <url>/GithubPage-hexo/Github-Hexo-%E5%9F%9F%E5%90%8D-%E5%85%8D%E8%B4%B9%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h5 id="目的"><a href="#目的：" class="headerlink" title="目的："></a>目的：</h5><p>​    本地通过WordPress编写blog然后git进行版本的管理，在浏览器上只需要输入自己购买的域名就可以成功访问。</p><h5 id="准备工作"><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h5><p>​    1.本地下载安装git ：<a href="https://git-scm.com/download/" target="_blank" rel="noopener">git官网下载地址</a></p><p>​    2.本地下载安装node：<a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">node官网下载地址</a></p><p>​    3.本地下载安装Hexo： </p><p>​        安装好上面的两项后直接打开cmd输入：npm install hexo-cli -g</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\安装HexoCMD.png" alt="安装HexoCMD"></p><p>​    4.创建github账号   格式 - 你为仓库取的名字.github.io(例如：blog.github.io因为普通的github会混淆)</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\创建仓库-1.png" alt="创建仓库-1"></p><p>​    <img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\创建仓库-2.png" alt="创建仓库-2"></p><h5 id="主要过程"><a href="#主要过程：" class="headerlink" title="主要过程："></a>主要过程：</h5><p>​    确定存放blog的路径，我的是e:/Blog；</p><p>​    Git Bash Here 打开：右键你的文件单击Git Bash Here；</p><p>​    在保证Git是在你的blog下操作的前提，开始初始化Hexo的文件夹：hexo init 你的仓库名字.github.io</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\初始化.png" alt="初始化"></p><p>​    稍等一会之后目录下就会有个文件夹，文件夹的名字就是你初始化的名字也就是仓库的名字</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\初始化后.png" alt="初始化后"></p><p>​    里面的文件及每个文件的作用如下：</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\本地文件含义.png" alt="本地文件含义"></p><p>​    走到这里就表示本地的简单搭建已经好了，默认的主题是landscape的主题</p><p>​    生成静态页面</p><p>​        进入到blog.github.io里面输入创建 hexo输入如下：</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\hexo创建.png" alt="hexo创建"></p><p>​        启动本地服务器，开启端口默认是4000.</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\hexo开启服务器.png" alt="hexo开启服务器"></p><p>​        浏览器输入<a href="https://link.jianshu.com/?t=http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a></p><p>​        下面会出先两种情况，一种顺利通过（跳过下面内容），另一种显示加载失败（端口被占/检查名字是否和仓库中一样）如果端口被占先Ctrl+C停止程序更改端口这里我改成5000。</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\该端口.png" alt="该端口"></p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\本地4000预览命令.png" alt="本地4000预览命令"></p><p>​        这时候你就可以进行预览了。</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\本地4000预览博客.png" alt="本地4000预览博客"></p><p>提交到GitHub</p><p>​        更改全局配置可以让hex直接和远端仓库连接打开_config.yml(注意格式，顺序，空格)</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\全局github库配置.png" alt="全局github库配置"></p><p>​        上面的repository填写的就是仓库的地址，下图位置复制进来就可；</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\拿到地址.png" alt="拿到地址"></p><p>​        首次部署附加内容：</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\首次部署内容.png" alt="首次部署内容"></p><p>​    添加完成后github的库就会增加一定的内容。看上图</p><p>​    下次更新时只需要先删除hexo在创建一个然后将配置上传就好</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\重新上传.png" alt="重新上传"></p><p>​    常用命令解释:</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\常用命令.png" alt="常用命令"></p><p>​    直接访问github博客 Settings-&gt;Github Pages -&gt;Source-&gt; master branch</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\ssettings访问-2.png" alt="ssettings访问-2"></p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\settings访问-1.png" alt="settings访问-1"></p><p>​    打开后因为css和js路径不对所以更换自定义的域名最好；</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\失败Hexo.png" alt="失败Hexo"></p><p>​    买域名-&gt;解析-&gt;添加俩A类记录 WWW 和 @ 服务器IP就填github的IP固定的151.101.72.133</p><p>​    在仓库中新建CNAME，文中写上你的域名，果断时间就可以直接访问了。</p><p>​    由于每次提交都会覆盖前一次，所以最好的是在本地留个位置，进入source看到_posts添加CNAME文件，加上自己的域名；</p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\本地添加Blog地址.png" alt="本地添加Blog地址"></p><p><img src="/GithubPage-hexo/Github-Hexo-域名-免费博客搭建指南/contentImg\添加域名.png" alt="添加域名"></p><h6 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h6><p>​    到这里你在浏览器上输入自己的域名就能直接访问自己的bolg了，最后恭喜你成功入坑，如果有什么不好的欢迎指教。如果对你有帮助希望有机会可以互相学习。</p>]]></content>
      
      
      <categories>
          
          <category> GithubPage; hexo; </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[U3D+Vuforia+VR眼镜] 分屏设置指南</title>
      <link href="/VR-AR%EF%BC%9B-Vuforia%EF%BC%9B-Unity3D/%5BU3D+Vuforia+VR%E7%9C%BC%E9%95%9C%5D%E5%88%86%E5%B1%8F%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/"/>
      <url>/VR-AR%EF%BC%9B-Vuforia%EF%BC%9B-Unity3D/%5BU3D+Vuforia+VR%E7%9C%BC%E9%95%9C%5D%E5%88%86%E5%B1%8F%E8%AE%BE%E7%BD%AE%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h6 id="版本"><a href="#版本" class="headerlink" title="版本:"></a>版本:</h6><p>​    unity 2018.2.14f1   Vuforia 7.2.20</p><h6 id="关键"><a href="#关键" class="headerlink" title="关键:"></a>关键:</h6><p>​    添加cardboard</p><p>​    将视觉改变为“video see Through”（windows-&gt; Vuforia Configuration-&gt;Digtal Eyewear），</p><h6 id="简介"><a href="#简介：" class="headerlink" title="简介："></a>简介：</h6><p>​    准备工作：</p><p>​        本地正确安装，并且成功配置Android SDK，NDK ，java JDK 的unity3D（注意版本，可参考我的版本）</p><p>​        Vurforia官网利用待测物体分析模型成功得到.unitypage的数据集 并成功生成 public key。</p><p>​        附：版本很重要，Vuforia 6.5之前的版本并没有自带VR眼镜的的功能，建议在安装U3D（unity3D以下用U3D代替）的时候确保在Vuforia一栏点选了默认安装系统会自动下载最新的Vuforia。</p><h6 id="步骤"><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h6><p>​        下面开始干活。进入U3D， 首先导入上面提到的待检测的.unitypage数据集:下面工具栏中project界面中的Assects，右击-&gt;import Package -&gt;Custom Package-&gt;进入自己存放数据集的地方直接点击import</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/导入待测数据集.png" alt="导入待测数据集"></p><p>​        下一步添加ARCamera（正常的MainCamera在AR的时候是不够的）：\<sample sence\="">空白处右击-&gt;vuforia-&gt;ARCamera（记得删除原有的MainCamera哦，右击delete）；</sample></p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\导入ARCamera.png" alt="导入ARCamera"></p><p>​        设置Camera的数据，在主屏右侧Inspector中选择（贴图参考）；</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\ARCamera参数参考.png" alt="ARCamera参数参考"></p><p>​        添加AR参照物(image Target)到Scence中：\<sample sence\="">空白处右击-&gt;Vuforia-&gt;Image</sample></p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\添加Image Traget.png" alt="添加Image Traget"></p><p>​        添加你想显示的虚拟对象，这里就直接从Asset Store中找一个免费的红武士进入搜索栏搜索“red Samurai”直接回车第二个标注Free的就是。没错点它-&gt;import</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\添加 红武士.png" alt="添加 红武士"></p><p>​        将添加到本地项目的红武士添加到界面中：Assets-&gt;prefab-&gt;红武士文件直接拖到image Target子目录下。</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\导入红武士.png" alt="导入红武士"></p><p>​        导入Vuforia配置：File-Bulid Setting 进入Build Setting界面点击android，右侧bulid system 选择Internal，-&gt;点击Player Settings进入inspector做以下几件事：</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\play Settings 改system.png" alt="play Settings 改system"></p><p>​            1.填写Company Name （随便填）；</p><p>​            2.点击Other Setting-&gt;identification 填写Package Name 注意格式com.Company Name.Product Name，需要注意的是，Company Name必须和上面填写的一样，Product Name可以不填。我的是com.chenchen.ProductName(参考)；</p><p>​            3.更改Minimum ARI Level等级，默认是16但是里面并不能支持此次开发，需要改成19，</p><p>​            4.在上面的基础上下拉，到Configurition栏，找到Android TV Compatbility系统默认是将这个选项是选上的你需要的是将它取消选择。</p><p>​            5.点开XR Settings三个选择点击第三个（Virtual augmented Reality）和第一个（Virtual Reality supported ），第三个如果不点在手机端生成的就是支持VR的不是不是AR的（看不到画面），第一个选择-&gt;为Virtual Reality SDKs添加-&gt;右下角“+”号-&gt;点击最下面的Vuforia</p><p>​        前四步：</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\play settings 前期多步.png" alt="play settings 前期多步"></p><p>​        第五步：<img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\添加vuforia.png" alt="添加vuforia"></p><p>​        下面一步比较重要，将Vuforia官网生成的PublicKey，配置进系统中激活U3D中的Vuforia：上面工具栏Window-&gt;Vuforia configuration,进入inspect，APP License Key 中将相关key 复制进去（这部是激活Vuforia）；</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\导入publicKey.png" alt="导入publicKey"></p><p>​        安装Cardboard：File-Bulid Setting 进入Build Setting界面点击android-&gt;点击Player Settings进入inspector-&gt;XR Settings 点击刚刚的第一个-&gt;“+”号-&gt;选择第一cardboard；</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\填加cardboard.png" alt="填加cardboard"></p><p>下一步更改视觉成像，改变成“video see Through”；回到上面加key的页面下面Digital Eyewear-&gt;Device Type -&gt;选择最后一个Phone + viewer 其他的根据自己的实际情况进行选择，我都是直接默认的。</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\public Key+Through.png" alt="public Key+Through"></p><p>​        最后一步直接生成apk 文件File-Bulid Setting 进入Build Setting 界面-&gt;android-&gt;Build;<img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\生成build.png" alt="生成build"></p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\生成apk文件.png" alt="生成apk文件"></p><p>以上就会用U3D Vuforia为基础创建一个在VR眼镜上的AR程序，手机显示分屏的哦。</p><p>​    手机成果：</p><p><img src="/VR-AR；-Vuforia；-Unity3D/[U3D+Vuforia+VR眼镜]分屏设置指南/content_img\手机生成结果.png" alt="手机生成结果"></p><h6 id="结语"><a href="#结语：" class="headerlink" title="结语："></a>结语：</h6><p>如有不足之处望各位大佬打脸，如果对你有帮助也希望有机会一起提高。</p>]]></content>
      
      
      <categories>
          
          <category> VR+AR； Vuforia； Unity3D </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XR </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>[Typora]操作指南</title>
      <link href="/article/%5BTypora%5D%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/"/>
      <url>/article/%5BTypora%5D%E6%93%8D%E4%BD%9C%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<p><strong>某天突发奇想,想创建一个博客，决定将以后学习和工作中遇到的有意思的内容都通过博客记录下来一方面是想让自己加深印像，努力让自己在这个技术快速更新迭代的时代不会被淘汰，另一方面也是想将自己的所学所感记录下来让更多想学习的人多一分突破的灵感，最后，由于首次编写，如果有笔误或者哪个地方理解不深希望各位老师多多批评指导。谢谢大家~~</strong></p><p>[TOC]</p><h5 id="简介"><a href="#简介：" class="headerlink" title="简介："></a>简介：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">介绍Typora就需要介绍Makedown，有的童鞋可能会说了这是什么鬼？其实很简单，makedown就是可以使用普通文本编辑器编辑的标记语言，简单点说就是简单的标记语法，可以使普通文本内容具有一定的格式，并对内容有一定的熏染作用，由于是轻量极的，实现的功能有限，所以就就出现了很多延伸的编译软件，而Typora就是MakeDown其中一个扩展，并且它是一个编写和显示结合的编辑器（有许多是分屏，一半编写一半是效果）并且主要一点：语法明了，易于上手，世界上最流行的博客平台WorldPress和大型CMS如Joomla，Drupal都能很好的支持它的格式。</span><br><span class="line"></span><br><span class="line">如果有兴趣的童鞋我可以推荐一款名叫：pandoc的开源转换工具，可以去研究，它可以实现常见的格式转换，并且支持全平台操作，以命令行的方式进行转换，以后有机会再另开一篇介绍，同附下载地址。</span><br></pre></td></tr></table></figure><h5 id="typora-下载地址"><a href="#Typora-下载地址：" class="headerlink" title="Typora 下载地址："></a>Typora 下载地址：</h5><p>​    <a href="https://www.typora.io/#windows" target="_blank" rel="noopener">Typora 下载地址</a>    </p><h5 id="1安装"><a href="#1-安装：" class="headerlink" title="1.安装："></a>1.安装：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">点击默认安装就ok，路径自由选择</span><br></pre></td></tr></table></figure><h5 id="pandoc-下载地址"><a href="#Pandoc-下载地址：" class="headerlink" title="Pandoc 下载地址："></a>Pandoc 下载地址：</h5><p>​    <a href="https://github.com/jgm/pandoc/releases/tag/2.1.3" target="_blank" rel="noopener">Pandoc 下载地址</a></p><h5 id="安装"><a href="#安装：" class="headerlink" title="安装："></a>安装：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双击安装默认进行，所生成的文件是.md结尾的</span><br></pre></td></tr></table></figure><h5 id="2使用"><a href="#2-使用：" class="headerlink" title="2.使用："></a>2.使用：</h5><h6 id="a标题"><a href="#A-标题：" class="headerlink" title="A.标题："></a>A.标题：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标题共有六级：一级最大六级最小。</span><br><span class="line"></span><br><span class="line">实现方法：第一种，几级标题就在标题前后加几个#；如 一级标题 ：  #    这是一级标题   #</span><br></pre></td></tr></table></figure><p>第二种，快捷键，直接在标题写完后直接按Ctrl+（你需要的标题数字）； 如：一级标题： 这是一级标题Ctrl+1；</p><h6 id="b文本"><a href="#B-文本：" class="headerlink" title="B.文本："></a>B.文本：</h6><h6 id="a居中"><a href="#a-居中：" class="headerlink" title="a.居中："></a>a.居中：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接在要居中的文本前后加上center标签就可以；</span><br><span class="line"></span><br><span class="line">\&lt;center\&gt;这是要居中的文本内容\&lt;/center\&gt;</span><br></pre></td></tr></table></figure><p>​         </p><h6 id="b下划线"><a href="#b-下划线" class="headerlink" title="b.下划线:"></a>b.下划线:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两种方法：1，在待操作内容前后加上u标签 例子： \&lt;u&gt; 下划线\&lt;/u&gt;</span><br><span class="line"></span><br><span class="line">2，在待操作内容后面直接Ctrl+u；</span><br><span class="line"></span><br><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure><h6 id="c删除线"><a href="#c-删除线" class="headerlink" title="c.删除线:"></a>c.删除线:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接在待操作内容前后加两个‘~~’ ；例子：~\~删除线~\~</span><br><span class="line"></span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>​    </p><h6 id="d字体加粗"><a href="#d-字体加粗" class="headerlink" title="d.字体加粗:"></a>d.字体加粗:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两种方法：1 在待操作数据前后加上两个‘**’   例如：\*\*加粗\*\*</span><br><span class="line"></span><br><span class="line">2 快捷键：直接在待操作文件后面加Ctrl+B</span><br><span class="line"></span><br><span class="line">**加粗**</span><br></pre></td></tr></table></figure><h6 id="e字体倾斜"><a href="#e-字体倾斜" class="headerlink" title="e.字体倾斜:"></a>e.字体倾斜:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">两个办法： 1 在待操作数据前后加一个‘*’ 例如：\*斜体\*</span><br><span class="line"></span><br><span class="line">2   在待操作内容后加Ctrl+i</span><br><span class="line"></span><br><span class="line">*斜体*</span><br></pre></td></tr></table></figure><h6 id="f图片插入"><a href="#f-图片插入" class="headerlink" title="f.图片插入:"></a>f.图片插入:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接拖拽到你想要的地点就好；</span><br></pre></td></tr></table></figure><h6 id="g超链接"><a href="#g-超链接：" class="headerlink" title="g.超链接："></a>g.超链接：</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">快捷键Ctrl+K</span><br><span class="line"></span><br><span class="line">\[自定义内容\]\(超链接地址\)   例如：\[百度一下\](http://www.baibu.com)</span><br><span class="line"></span><br><span class="line">[百度一下](http://www.baidu.com)</span><br></pre></td></tr></table></figure><p>​    </p><h6 id="h代码区域"><a href="#h-代码区域" class="headerlink" title="h.代码区域:"></a>h.代码区域:</h6><p>Typora支持对多语言的代码区域进行<strong>语法高亮</strong>。里面的原因涵盖了大部分经常使用的编程语言，其中包括C++，Python，java ，甚至包含spreadsheet(也就是Excel电子表格)，如果设置代码语言为flow，还可以直接画出流程图；还可以使用相应的方法画出时序图等图表。</p><p><strong>使用格式</strong>：```+编程语言    如：  ```java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demo</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        System.out.println(“This is Java Code”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">mian()&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;“This is C++ Code”&lt;&lt;end1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="i表格"><a href="#i-表格" class="headerlink" title="i.表格:"></a>i.表格:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">快捷键 ctrl+T ，自动跳出行和列的设置框，</span><br></pre></td></tr></table></figure><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td></td></tr></tbody></table><h6 id="j自动生成目录列表"><a href="#j-自动生成目录列表" class="headerlink" title="j.自动生成目录列表:"></a>j.自动生成目录列表:</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\[toc]回车就好，这个目录抽取文章所有标题</span><br></pre></td></tr></table></figure><h6 id="k任务列表"><a href="#k-任务列表" class="headerlink" title="k.任务列表:"></a>k.任务列表:</h6><p>前面加  -     +    *   效果都是一样的。</p><p>-  [ ] 文字（注意空格，- 后有一个，括号有空格，文字前有空格）</p><p>- [ ] 文字</p><ul><li style="list-style: none"><input type="checkbox"> 文字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">###### l.水平分割线:</span><br></pre></td></tr></table></figure><p>***或者—</p><hr><hr><h6 id="m引用"><a href="#m-引用" class="headerlink" title="m.引用:"></a>m.引用:</h6><p>>+空格</p><blockquote><ul><li>这里是引用的内容</li></ul></blockquote><h6 id="n标注"><a href="#n-标注" class="headerlink" title="n.标注:"></a>n.标注:</h6><p>这是标注<a href="没错它显示的就是这个内容。">^标题</a></p><p>格式：文字[\^标注的文字]</p><p>注解 内容部分格式：[^上面标注的文字]:对上面内容解释。</p><h6 id="o流程图"><a href="#o-流程图" class="headerlink" title="o.流程图:"></a>o.流程图:</h6><p>关于流程图，我查阅了相关的内容typora并没有直接绘图的，但是现在我不过如果想实现有两种方法，一种是在设置中将编些格式转化成为为makedown的格式然后安装makedown的格式进行编写，但是这个比较复杂，主要推荐第二种，就是将自己要实现的流程提通过电脑系统知道的画图软件就可以直接生成好，利用屏幕截取功能（如果不知道电脑屏幕截取快捷键就直接打开腾讯QQ就可以了）将生成好的图片直接拖进去就可以。</p><p><strong>以上就是本次编写关于typora的全部内容，当然还有很多没有列举出来比如数学公式，但上面都是一个程序员常用的部分，希望我的分享能够给你带来实质性的帮助，读完之后如果有什么意见或建议非常希望您能提出来，我也会积极的去改正。</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
